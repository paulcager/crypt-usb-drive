#!/bin/bash 

set -e -o pipefail

dd() {
	/usr/bin/dd 2>/dev/null "$@"
}

# Minimum number of blocks mkfs.ext2 will accept is 60
BLOCKS=64
KEY_FILE_SIZE=128
KEY_PLACEHOLDER="$(dd 2>/dev/null if=/dev/zero bs=$KEY_FILE_SIZE count=1 | tr '\000' X)"

dd if=/dev/zero of=image.ext2 bs=1024 count=${BLOCKS}
mke2fs -b 1024 -E root_owner=0:0 -F -L KEYS -i 4096 -I 256 -m 0 -t ext2 image.ext2 1>&2

# Create directory in the image with minimal permissions.
e2mkdir -O 0 -G 0 -P 100 image.ext2:keys

# Create blank 128-byte keyfile in the image.
echo -n "${KEY_PLACEHOLDER}" | e2cp -G 0 -O 0 -P 400 - image.ext2:keys/key
# Note that e2rm -r image.ext2:lost+found results in a corrupt filesystem; leave it there.

# We have enough inodes to create the following if necessary:
#dd if=/dev/zero bs=$KEY_FILE_SIZE count=1 | tr '\000' Y | e2cp -G 0 -O 0 -P 400 - image.ext2:keys/key2
#dd if=/dev/zero bs=$KEY_FILE_SIZE count=1 | tr '\000' Z | e2cp -G 0 -O 0 -P 400 - image.ext2:keys/key3
#dd if=/dev/zero bs=$KEY_FILE_SIZE count=1 | tr '\000' A | e2cp -G 0 -O 0 -P 400 - image.ext2:keys/key4

getBlock() {
  local block=$1
  dd 2>/dev/null if=image.ext2 bs=1024 skip=$block count=1
}

sum() {
  getBlock $1 | sha256sum | awk '{print $1}'
}

declare -A block_sums
declare -A contents

DATA_BLOCK=unknown

for ((i=0; i < BLOCKS; i++)) {
	if [ "$(getBlock $i | sed 's/\x00//g')" == "${KEY_PLACEHOLDER}" ]; then
	  if [ "$DATA_BLOCK" != unknown ]; then
	    echo "2 data blocks?? $DATA_BLOCK and $i" >&2
	    exit 2
	  fi
	  DATA_BLOCK=$i
	  continue
	fi

	b="$(getBlock $i |  xxd -i -c 512)"
	sum="$(sum $i)"
	block_sums[$i]=$sum
	contents[$sum]="$b"
}

cat >src/image.h <<EOF
//
// This file is automatically generated - do not edit.
//

#include <pico/platform.h>

#define BLOCK_SIZE 1024
#define NUM_BLOCKS ${BLOCKS}

extern const uint8_t *disk_blocks[NUM_BLOCKS];

// One of these blocks will contain the file contents
extern uint8_t file_contents[BLOCK_SIZE];

EOF

cat >src/image.c <<EOF
//
// This file is automatically generated - do not edit.
//

#include <image.h>

// There are ${#contents[@]} distinct blocks out of ${BLOCKS}.
// DATA_BLOCK is ${DATA_BLOCK}.

uint8_t file_contents[BLOCK_SIZE];

$(
  for sum in "${!contents[@]}"; do
    echo "const uint8_t __in_flash() disk_blocks_$sum[BLOCK_SIZE] = {"
    echo "${contents[$sum]}"
    echo "};"
  done
)

const uint8_t *disk_blocks[NUM_BLOCKS] = {

$(
  for ((i=0; i < BLOCKS; i++)) {
    if [ $i == $DATA_BLOCK ]; then
      echo "  file_contents,"
      continue
    fi
    echo "  disk_blocks_${block_sums[$i]},"
  }
)
};

EOF


